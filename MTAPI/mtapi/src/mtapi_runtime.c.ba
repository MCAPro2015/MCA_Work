#ifdef __cplusplus
  extern "C" {
#endif
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <sched.h>
#include "mtapi.h"
#include "mtapi_runtime.h"
#include "mcapi.h"
//#include "mrapi.h"
//#include "queue.h"
#include "pthread.h"

#define TLS __thread
#define NUM_WORKER  4

int thread_id[NUM_WORKER];

TLS mtapiRT_TaskInfo_t * __current_task = MTAPI_NULL;

mtapi_domain_t __mtapi_domain;
TLS mtapi_node_t __mtapi_node;
mtapi_domain_t __mtapi_listener_domain;
mtapi_node_t __mtapi_listener_node;
unsigned __mtapi_init_node_id;
mutex_t __mtapi_task_id_mutex;
unsigned __mtapi_task_id;

unsigned __mtapi_queue_id;
mutex_t __mtapi_queue_id_mutex;
mtapiRT_QueueInfo_t * queueGroup[1];

int __listenerActive;

TLS mcapi_endpoint_t __send_endpoint;
mtapiRT_ActionInfo_t * __mtapi_actions;
mtapiRT_JobInfo_t * __mtapi_jobs;
mcapi_port_t __portNum[MCAPI_MAX_ENDPOINTS];
mutex_t __portMutex;
queue_t *__task_queue;
queue_t *__remote_task_queue;
queue_t *__completed_task_queue;
list_t * __mtapi_remote_task_list;


/* thread id for worker and listener*/

pthread_t worker_id[NUM_WORKER];
pthread_t listener_id;

#define mtapi_assert(x) MTAPI_ASSERT(x, __LINE__);



void MTAPI_ASSERT(mtapi_boolean_t condition, unsigned line)
{
	if (!condition) {
		fprintf(stderr, "INTERNAL ERROR: MTAPI failed assertion(mtapi_runtime.c:%d) shutting down\n", line);
		exit(1);
	}
}

void *worker_routine(void * arg)
{
	int * thread_id;
	thread_id = (int *) arg;
	mcapi_status_t mcapi_status;
	mcapi_info_t mcapi_info;
	__mtapi_node = *thread_id;
	mtapi_status_t mtapi_status;
	mcapi_initialize(
		__mtapi_domain,
		*thread_id,
		MCAPI_NULL,
		MCAPI_NULL,
		&mcapi_info,
		&mcapi_status
		);
	__send_endpoint = mcapi_endpoint_create(0, &mcapi_status);

	void * ptr = NULL;
	mtapiRT_TaskInfo_t *task;
	void * seq_task;
	while(1) {
		queue_lock(__task_queue);
		ptr = queue_dequeue(__task_queue);
		queue_unlock(__task_queue);
		if (ptr == NULL) 
		{
			if (queueGroup[0] != MTAPI_NULL) {
				
				mutex_lock(&queueGroup[0]->mutex);
				if (queueGroup[0]->avail == MTAPI_TRUE) 
				{
					seq_task = queue_dequeue(queueGroup[0]->seq_task_queue);
					if (seq_task) {
						queueGroup[0]->avail = MTAPI_FALSE;
						queue_lock(__task_queue);
						queue_enqueue(__task_queue, seq_task);
						queue_unlock(__task_queue);
					}
				}
				mutex_unlock(&queueGroup[0]->mutex);
				
			}
			continue;
		}
		task = (mtapiRT_TaskInfo_t *) ptr;

		if (task->action->status != MTAPIRT_ACTION_CREATED) {
			task->action->status = MTAPI_TASK_CANCELLED;
			continue;
		}
		/*
		if (task->action->type == MTAPIRT_ACTION_REMOTE) {
			if (task->context->status != MTAPI_TASK_COMPLETED) {
				queue_lock(__task_queue);
				queue_enqueue(__task_queue, (void *) task);
				queue_unlock(__task_queue);
			}
			continue;
		}
		*/
		/* this is current task for this worker routine */
		__current_task = task;
		mutex_lock(&__mtapi_jobs[task->action->jobID].mutex);
		__mtapi_jobs[task->action->jobID].running++;
		mutex_unlock(&__mtapi_jobs[task->action->jobID].mutex);
		mutex_lock(&task->action->mutex);
		task->action->running++;
		mutex_unlock(&task->action->mutex);

		mutex_lock(&task->mutex);
		task->context->status = MTAPI_TASK_RUNNING;
		task->action->location.fptr (
				task->arguments,
				task->argument_size,
				task->result_buffer,
				task->result_size,
				task->action->local_data,
				task->action->local_data_size,
				(mtapi_task_context_t * const)task->context
				);
		task->context->status = MTAPI_TASK_COMPLETED;
		if (task->queue != MTAPI_NULL) {
			mutex_lock(&task->queue->mutex);
			task->queue->avail = MTAPI_TRUE;
			mutex_unlock(&task->queue->mutex);
		}
		mutex_unlock(&task->mutex);
		mutex_lock(&__mtapi_jobs[task->action->jobID].mutex);
		__mtapi_jobs[task->action->jobID].running--;
		mutex_unlock(&__mtapi_jobs[task->action->jobID].mutex);
		mutex_lock(&task->action->mutex);
		task->action->running--;
		mutex_unlock(&task->action->mutex);
		__sync_fetch_and_add(&task->action->cnt, -1);
		
		
		/*
		if (*(int *) task->arguments == 22){
			printf("%p   %d   %d\n",task, *(int *) task->arguments, *(int *) task->result_buffer);
		}
		*/
		if (task->FromRemote == 1) {
			mtapiRT_sendResult(task, task->init_node, &mtapi_status);
//			queue_lock(__completed_task_queue);
//			queue_enqueue(__completed_task_queue, (void *)task);
//			queue_unlock(__completed_task_queue);
		} 
	}	
}

void * listener_routine()
{
	mcapi_status_t mcapi_status;
	mcapi_endpoint_t recvEndpoint, remoteEndpoint;
	mcapi_info_t mcapi_info;
//	mtapiRT_Message_t msg;
	mcapi_uint_t nrMessages;
	mtapiRT_Message_t package;
	char buffer[MCAPI_MAX_MSG_SIZE];
	size_t msg_size;
	
	mcapi_initialize(
			__mtapi_listener_domain,
			__mtapi_listener_node,
			MCAPI_NULL,
			MCAPI_NULL,
			&mcapi_info,
			&mcapi_status
			);
	recvEndpoint = mcapi_endpoint_create(NODE_INFOS[__mtapi_init_node_id].lst_recv_port, &mcapi_status);

	__listenerActive = 1;

	while (__listenerActive){
		nrMessages = mcapi_msg_available(recvEndpoint, &mcapi_status);
		if (!nrMessages) {
			sched_yield();
			continue;
		}
		mcapi_msg_recv(recvEndpoint, &buffer, MCAPI_MAX_MSG_SIZE, &msg_size, &mcapi_status);
		if (mcapi_status != MCAPI_SUCCESS) {
			printf("listener receiving error\n");
		}
		__unmarshallMessage(buffer, msg_size, &package);
		/* get the endpoint which sends this message */

		remoteEndpoint = mcapi_endpoint_get(
				package.sender_domain,
				package.sender_node,
				package.port,
				MCAPI_TIMEOUT_INFINITE,
				&mcapi_status);
		if (mcapi_status != MCAPI_SUCCESS) {
			printf("getting remote endpoint failure\n");
		}
		switch (package.type) {
			case MTAPIRT_MSG_START_TASK :
				__lst_startTask(&package, recvEndpoint, remoteEndpoint);
				break;
			case MTAPIRT_MSG_WAIT_TASK:
				__lst_waitForTask(&package, recvEndpoint, remoteEndpoint);
				break;
			case MTAPIRT_MSG_UPDATE_ACTION:
				__lst_updateAction(&package, recvEndpoint, remoteEndpoint);
				break;
			case MTAPIRT_MSG_UPDATE_ACTION_2:
				__lst_updateAction2(&package, recvEndpoint, remoteEndpoint);
				break;
			case MTAPIRT_MSG_DELETE_ACTION:
				__lst_updateActionDelete(&package, recvEndpoint, remoteEndpoint);
				break;
			case MTAPIRT_MSG_COMPLETE_TASK:
				__lst_taskCompleted(&package, recvEndpoint, remoteEndpoint);
				break;
			case MTAPIRT_MSG_SYNC:
			case MTAPIRT_MSG_ACK:
			case MTAPIRT_MSG_NACK:
			case MTAPIRT_MSG_GET_ACTION:
			case MTAPIRT_MSG_CANCEL_TASK:
			case MTAPIRT_MSG_CREATE_ACTION:
			case MTAPIRT_MSG_DISABLE_ACTION:
			case MTAPIRT_MSG_ENABLE_ACTION:
				break;
		}
	}
	return MTAPI_NULL;
	

	
}
void mtapiRT_initialize(MTAPI_IN mtapi_domain_t domain_id, 
		        MTAPI_IN mtapi_node_t node_id,
			MTAPI_OUT mtapi_info_t *mtapi_info,
			mtapi_status_t * status)
{
	int i, j, k;
	int rc;
	rc = MCAPI_MAX_ENDPOINTS;
	mtapiRT_ActionInfo_t * remoteActionInfo;
	mtapiRT_ActionInfo_t * tmpActionInfo;
	/*
	 * initialize __portNum
	 */

	__mtapi_domain = domain_id;
	__mtapi_node = node_id;
	__mtapi_listener_domain = __mtapi_domain;
	__mtapi_listener_node = __mtapi_node + 1;
	__mtapi_task_id = 0;
	mutex_init(&__mtapi_task_id_mutex);
	for (i = 0; i < MCAPI_MAX_ENDPOINTS; i++) {
		__portNum[i] = 0;
	}
	mutex_init(&__portMutex);
	/*
	 *  get the node id
	 */
	for (i = 0; i < NUM_NODES; i++) {
		if (NODE_INFOS[i].domain == domain_id && NODE_INFOS[i].node == node_id) {
			__mtapi_init_node_id = i;
		}
	}
	__send_endpoint = mcapi_endpoint_create(NODE_INFOS[__mtapi_init_node_id].req_send_port, status);
        /*
	 *  initialize __mtapi_actions for each node
	 */
	__mtapi_actions = (mtapiRT_ActionInfo_t *) malloc (NODE_INFOS[__mtapi_init_node_id].num_actions * sizeof(mtapiRT_ActionInfo_t));
	for (i = 0; i < NODE_INFOS[__mtapi_init_node_id].num_actions; i++) {
		mutex_init(&__mtapi_actions[i].mutex);
//		mutex_lock(&__mtapi_actions[i].mutex);
		__mtapi_actions[i].jobID = NODE_INFOS[__mtapi_init_node_id].actions[i];
		__mtapi_actions[i].status = MTAPIRT_ACTION_NULL;
		__mtapi_actions[i].type = MTAPIRT_ACTION_LOCAL;
		__mtapi_actions[i].cnt = 0;
		__mtapi_actions[i].running = 0;
		__mtapi_actions[i].next = MTAPI_NULL;
		__mtapi_actions[i].attributes = MTAPI_NULL;
//		mutex_unlock(&__mtapi_actions[i].mutex);
	}

	/*
	 *  initialize __mtapi_jobs for each node. each job will associate 
	 *  with a pointer to the action. If the mtapiRT_ActionInfo is on
	 *  this node. It will attached to its address. Otherwise will 
	 *  create one marked with MTAPIRT_ACTION_REMOTE and attach to 
	 *  this job.
	 *
	 */
	__mtapi_jobs = (mtapiRT_JobInfo_t *) malloc (sizeof(mtapiRT_JobInfo_t) * NUM_JOBS);
	for (i = 0; i < NUM_JOBS; i++) {
		__mtapi_jobs[i].running = 0;
		__mtapi_jobs[i].job_id = i;
		__mtapi_jobs[i].actions = NULL;
		mutex_init(&__mtapi_jobs[i].mutex);
	}
	/*  first attach local action */
	for (i = 0; i < NUM_JOBS; i++) {
		for (j = 0; j < NODE_INFOS[__mtapi_init_node_id].num_actions; j ++) {
			if (__mtapi_actions[j].jobID == i) {
				__mtapi_jobs[i].actions = &__mtapi_actions[j];
			}
		}
	}

	/*  attach remote action */
	for (i = 0; i < NUM_JOBS; i++) {
		for (j = 0; j < NUM_NODES; j++) {
			if (j == __mtapi_init_node_id) {
				continue;
			}
			for (k = 0; k < NODE_INFOS[j].num_actions; k++) {
				if (NODE_INFOS[j].actions[k] != i) {
					continue;
				}
				remoteActionInfo = (mtapiRT_ActionInfo_t *) malloc (sizeof(mtapiRT_ActionInfo_t));
				mutex_init(&remoteActionInfo->mutex);
				remoteActionInfo->jobID = i;

				remoteActionInfo->status = MTAPIRT_ACTION_NULL;
				remoteActionInfo->type = MTAPIRT_ACTION_REMOTE;
				remoteActionInfo->location.init_node = j;
				remoteActionInfo->cnt = 0;
				remoteActionInfo->running = 0;
				remoteActionInfo->next = MTAPI_NULL;
				remoteActionInfo->attributes = MTAPI_NULL;
				/*  attach remote action to tail of __mtapi_jobs */
				if (__mtapi_jobs[i].actions == MTAPI_NULL) {
					__mtapi_jobs[i].actions = remoteActionInfo;
				} else {
					tmpActionInfo = __mtapi_jobs[i].actions;
					while (tmpActionInfo->next != MTAPI_NULL) {
						tmpActionInfo = tmpActionInfo->next;
					}
					tmpActionInfo->next = remoteActionInfo;
				}
			}

		
		}
	}

	/* initialize task queue */

	__task_queue = (queue_t *) malloc (sizeof (queue_t));
	queue_init(__task_queue);
	__completed_task_queue = (queue_t *) malloc (sizeof(queue_t));
	queue_init(__completed_task_queue);
	__remote_task_queue = (queue_t *) malloc (sizeof(queue_t));
	queue_init(__remote_task_queue);

	/* initialize queuegroup */
	__mtapi_queue_id = 0;
	mutex_init(&__mtapi_queue_id_mutex);

	queueGroup[0] = MTAPI_NULL;

	/* initialize list for remote task */
	__mtapi_remote_task_list = (list_t *) malloc (sizeof(list_t));
	list_init(__mtapi_remote_task_list);
	

	/* launch listener routine */
	rc = pthread_create(&listener_id, NULL, listener_routine, NULL);
	if (rc) {
		fprintf(stderr, "Fail to create listener thread\n");
	}
	/* launch the worker routine */
	for (i = 0; i < NUM_WORKER; i++) {
		thread_id[i] = __mtapi_node + i + 10;
	}

	for (i = 0; i < NUM_WORKER; i ++) {
		
		rc = pthread_create(&worker_id[i], NULL, worker_routine, (void *) &thread_id[i]);
		if (rc) {
			fprintf(stderr, "Fail to create worker thread\n");
		}
	}
	__current_task = MTAPI_NULL;
}

/*
 *  create the local action on each node
 */

mtapiRT_ActionInfo_t * mtapiRT_createAction (
		MTAPI_IN mtapi_job_id_t job,
		MTAPI_IN mtapi_action_function_t function,
		MTAPI_IN void * node_local_data,
		MTAPI_IN mtapi_size_t node_local_data_size,
		MTAPI_IN mtapi_action_attributes_t * attributes,
		MTAPI_OUT mtapi_status_t * status
		)
{
	/*  the first action in __mtapi_jobs[job].actions is local action*/
	mtapiRT_ActionInfo_t * action = __mtapi_jobs[job].actions;
	if (action == MTAPI_NULL) {
		fprintf(stderr, "mtapiRT_createAction Error: action does not exist\n");
		return MTAPI_NULL;
	}

	if (action->type != MTAPIRT_ACTION_LOCAL) {
		fprintf(stderr, "mtapiRT_createAction Error: create a non-local action\n ");
		return MTAPI_NULL;
	}

	/*  create local action  */
        mutex_lock(&action->mutex);
	action->status = MTAPIRT_ACTION_CREATED;
	action->location.fptr = function;
	action->local_data = node_local_data;
	action->local_data_size = node_local_data_size;
	action->attributes = attributes;
	mutex_unlock(&action->mutex);
	mtapiRT_action_status_t actionStatus = MTAPIRT_ACTION_CREATED;
	mtapiRT_MessageType_t messageType = MTAPIRT_MSG_UPDATE_ACTION;
	mtapiRT_broadcastActionUpdate(actionStatus, messageType , status);
	return action;
}

void mtapiRT_deleteAction(
		mtapiRT_ActionInfo_t *action,
		mtapi_timeout_t timeout,
		mtapi_status_t * status
		)
{
	mtapiRT_action_status_t actionStatus = MTAPIRT_ACTION_DELETED;
	mtapiRT_MessageType_t messageType = MTAPIRT_MSG_DELETE_ACTION;
	mutex_lock(&action->mutex);
	action->status = MTAPIRT_ACTION_DELETED;
	mtapiRT_broadcastActionUpdate(actionStatus, messageType, status);
	mutex_unlock(&action->mutex);
}

	/* broadcast to all processes that action has been created */
void mtapiRT_broadcastActionUpdate(mtapiRT_action_status_t actionStatus, mtapiRT_MessageType_t messageType, mtapi_status_t * status)
{

	mcapi_endpoint_t remoteEndpt[NUM_NODES];
	mcapi_status_t mcapi_status;
	mcapi_request_t req[NUM_NODES];
	int i;
	int cnt = 0;
	int j = 0;
	char buffer[MCAPI_MAX_MSG_SIZE];
	unsigned send_size;
//	unsigned recv_size;

	mtapiRT_ActionUpdate_t * update;
	update = (mtapiRT_ActionUpdate_t *) malloc (sizeof(mtapiRT_ActionUpdate_t));

	for (i = 0; i < NODE_INFOS[__mtapi_init_node_id].num_actions; i++) {
		if (__mtapi_actions[i].status == actionStatus) {
			update->job[j] = __mtapi_actions[i].jobID;
			cnt++;
		}
	}
	update->num_created_action = cnt;
	update->init_node = __mtapi_init_node_id;


	mtapiRT_Message_t * msg;
        msg = (mtapiRT_Message_t *) malloc (sizeof(mtapiRT_Message_t));	
	msg->type = messageType;
	msg->sender_domain = __mtapi_domain;
	msg->sender_node = __mtapi_node;
	msg->port = 0;
	msg->buffer = (void *) update;
	msg->buffer_size = sizeof(mtapiRT_ActionUpdate_t);
	send_size = __marshallMessage(msg, buffer);
	for (i = 0; i < NUM_NODES; i++) {
		if (i != __mtapi_init_node_id) {
			mcapi_endpoint_get_i(
					NODE_INFOS[i].domain,
					NODE_INFOS[i].node + 1,
					NODE_INFOS[i].lst_recv_port,
					&remoteEndpt[i],
					&req[i],
					&mcapi_status
					);
			mcapi_msg_send_i (
					__send_endpoint,
					remoteEndpt[i],
					&buffer,
					send_size,
					MCAPI_MAX_PRIORITY,
					&req[i],
					&mcapi_status
					);
		}
	}
	*status = MTAPI_SUCCESS;
}

/*
 *  get the current best action (at this stage we only pick the action
 *  which has the least running counter) to be the best action for 
 *  current job 
 */
/*
mtapiRT_ActionInfo_t * mtapiRT_getBestAction(mtapiRT_JobInfo_t * job, mtapi_status_t * status)
{
	int min;
	mtapiRT_ActionInfo_t * tmpAction;
	mtapiRT_ActionInfo_t * currentAction;
	currentAction = job->actions;
	if (currentAction->running == 0 && currentAction->status == MTAPIRT_ACTION_CREATED) {
		*status = MTAPI_SUCCESS;
		return currentAction;
	}
	tmpAction = currentAction;
	while (tmpAction->next != MTAPI_NULL) {
		min = currentAction->running;
		tmpAction = tmpAction->next;
		if (tmpAction->running < min && tmpAction->status == MTAPIRT_ACTION_CREATED) {
			currentAction = tmpAction;
		}
	}
	if (currentAction->status == MTAPIRT_ACTION_CREATED) {
		*status = MTAPI_SUCCESS;
		return currentAction;
	} else {
		*status = MTAPI_ERR_ACTION_INVALID;
		return MTAPI_NULL;
	}
}
*/
mtapiRT_ActionInfo_t * mtapiRT_getBestAction(mtapiRT_JobInfo_t * job, mtapi_status_t * status)
{
	int min;
	mtapiRT_ActionInfo_t * tmpAction;
	mtapiRT_ActionInfo_t * currentAction;
	currentAction = job->actions;
	/*  prefer local action  */
	if (currentAction->cnt == 0 && currentAction->status == MTAPIRT_ACTION_CREATED) {
		__sync_fetch_and_add(&currentAction->cnt, 1);
		*status = MTAPI_SUCCESS;
		return currentAction;
	}
	/* return action with min running counter */
	tmpAction = currentAction;
	while (tmpAction->next != MTAPI_NULL) {
		min = currentAction->cnt;
		tmpAction = tmpAction->next;
		if (tmpAction->cnt < min && tmpAction->status == MTAPIRT_ACTION_CREATED) {
			currentAction = tmpAction;
		}
	}
	/* not sure if it is necessary cause the next steps will keep checking this */
	if (currentAction->status == MTAPIRT_ACTION_CREATED) {
		__sync_fetch_and_add(&currentAction->cnt, 1);
		*status = MTAPI_SUCCESS;
		return currentAction;
	} else {
		*status = MTAPI_ERR_ACTION_INVALID;
		return MTAPI_NULL;
	}
}

mtapiRT_ActionInfo_t * mtapiRT_getBestActionQueue(mtapiRT_QueueInfo_t * queue, mtapi_status_t * status)
{
	mtapiRT_ActionInfo_t * action;
	action = mtapiRT_getBestAction (queue->job, status);
	*status = MTAPI_SUCCESS;
	return action;
}

mtapiRT_TaskInfo_t * mtapiRT_startLocalTask(
		int IsFromRemote,
		unsigned node,
		MTAPI_IN mtapi_task_id_t task_id,
		mtapiRT_ActionInfo_t * action,
		MTAPI_IN void * arguments,
		MTAPI_IN mtapi_size_t arguments_size,
		MTAPI_OUT void * result_buffer,
		MTAPI_IN mtapi_size_t result_size,
		MTAPI_IN mtapi_task_attributes_t * attributes,
		MTAPI_OUT mtapi_status_t *status
		)
{
	/* initialize a task node */
//	mcapi_status_t mcapi_status;
	mtapiRT_TaskInfo_t * taskInfo;
	if (action->status != MTAPIRT_ACTION_CREATED) {
		*status = MTAPI_ERR_ACTION_INVALID;
		return MTAPI_NULL;
	}
	taskInfo = (mtapiRT_TaskInfo_t *) malloc (sizeof (mtapiRT_TaskInfo_t));
	taskInfo->task_id = task_id;
	if (IsFromRemote) {
		taskInfo->init_node = node;
	} else {
		taskInfo->init_node = __mtapi_init_node_id;
	}
	taskInfo->queueID = -1;
	taskInfo->queue = MTAPI_NULL;
	mutex_lock(&__mtapi_task_id_mutex);
	taskInfo->internal_task_id = __mtapi_task_id++;
	/* for task in local task queue, the external_task_id 	*
	 * is set to -1						*/
	taskInfo->external_task_id = -1;
	mutex_unlock(&__mtapi_task_id_mutex);
	taskInfo->action = action;
	taskInfo->arguments = arguments;
	taskInfo->argument_size = arguments_size;
	taskInfo->result_buffer = result_buffer;
	taskInfo->result_size = result_size;
	taskInfo->attributes = attributes;
//	taskInfo->port = __getNextPortNum();
//	taskInfo->endpoint = mcapi_endpoint_create(taskInfo->port, &mcapi_status);
	taskInfo->context = (mtapi_task_context_t *) malloc (sizeof(mtapi_task_context_t));
	taskInfo->FromRemote = IsFromRemote;
	taskInfo->context->status = MTAPI_TASK_SCHEDULED;
	mutex_init(&taskInfo->mutex);

	if (__current_task == NULL) {
		/* this is the first task for program */
		taskInfo->num_children = 0;
		__current_task = taskInfo;
		__current_task->parent = MTAPI_NULL;
		__current_task->child = MTAPI_NULL;
	} else {
		/* this is not the first task for program */
		__current_task->child = taskInfo;
		taskInfo->parent = __current_task;
		taskInfo->child = MTAPI_NULL;
		taskInfo->num_children = 0;
		__current_task->num_children++;
	}

	/* insert a task node into the queue */
//	queue_lock(__task_queue);
	/* task cut off when task queue is full */
	if (queue_is_full(__task_queue) == 1) {
		printf("task cut-off\n");
		__current_task = taskInfo;
		mutex_lock(&__mtapi_jobs[taskInfo->action->jobID].mutex);
		__mtapi_jobs[taskInfo->action->jobID].running++;
		mutex_unlock(&__mtapi_jobs[taskInfo->action->jobID].mutex);
		mutex_lock(&taskInfo->action->mutex);
		taskInfo->action->running++;
		mutex_unlock(&taskInfo->action->mutex);

		mutex_lock(&taskInfo->mutex);
		taskInfo->context->status = MTAPI_TASK_RUNNING;
		taskInfo->action->location.fptr (
				taskInfo->arguments,
				taskInfo->argument_size,
				taskInfo->result_buffer,
				taskInfo->result_size,
				taskInfo->action->local_data,
				taskInfo->action->local_data_size,
				(mtapi_task_context_t * const)taskInfo->context
				);
		taskInfo->context->status = MTAPI_TASK_COMPLETED;
		if (taskInfo->queue != MTAPI_NULL) {
			mutex_lock (&taskInfo->queue->mutex);
			taskInfo->queue->avail = MTAPI_TRUE;
			mutex_unlock(&taskInfo->queue->mutex);
		}
		mutex_unlock(&taskInfo->mutex);
		mutex_lock(&__mtapi_jobs[taskInfo->action->jobID].mutex);
		__mtapi_jobs[taskInfo->action->jobID].running--;
		mutex_unlock(&__mtapi_jobs[taskInfo->action->jobID].mutex);
		mutex_lock(&taskInfo->action->mutex);
		taskInfo->action->running--;
		mutex_unlock(&taskInfo->action->mutex);
		__sync_fetch_and_add(&taskInfo->action->cnt, -1);
		/*
		if (*(int *) task->arguments == 22){
			printf("%p   %d   %d\n",task, *(int *) task->arguments, *(int *) task->result_buffer);
		}
		*/
		if (taskInfo->FromRemote == 1) {
			mtapiRT_sendResult(taskInfo, taskInfo->init_node, status);
//			queue_lock(__completed_task_queue);
//			queue_enqueue(__completed_task_queue, (void *)taskInfo);
//			queue_unlock(__completed_task_queue);
		} 

	} else {
		queue_lock(__task_queue);
		queue_enqueue(__task_queue, (void *) taskInfo);
		queue_unlock(__task_queue);
	}
//	queue_unlock(__task_queue);

	return taskInfo;
}

mtapiRT_TaskInfo_t * mtapiRT_startLocalTaskQueue(
		int IsFromRemote,
		mtapiRT_QueueInfo_t * queue,
		MTAPI_IN mtapi_task_id_t task_id,
		mtapiRT_ActionInfo_t * action,
		MTAPI_IN void * arguments,
		MTAPI_IN mtapi_size_t arguments_size,
		MTAPI_OUT void * result_buffer,
		MTAPI_IN mtapi_size_t result_size,
		MTAPI_IN mtapi_task_attributes_t * attributes,
		MTAPI_OUT mtapi_status_t *status
		)
{
	/* initialize a task node */
//	mcapi_status_t mcapi_status;
	mtapiRT_TaskInfo_t * taskInfo;
	if (action->status != MTAPIRT_ACTION_CREATED) {
		*status = MTAPI_ERR_ACTION_INVALID;
		return MTAPI_NULL;
	}
	taskInfo = (mtapiRT_TaskInfo_t *) malloc (sizeof (mtapiRT_TaskInfo_t));
	taskInfo->task_id = task_id;
	taskInfo->queue = queue;
	taskInfo->queueID = queue->internal_queue_id;
	mutex_lock(&__mtapi_task_id_mutex);
	taskInfo->internal_task_id = __mtapi_task_id++;
	/* for task in local task queue, the external_task_id 	*
	 * is set to -1						*/
	taskInfo->external_task_id = -1;
	mutex_unlock(&__mtapi_task_id_mutex);
	taskInfo->action = action;
	taskInfo->arguments = arguments;
	taskInfo->argument_size = arguments_size;
	taskInfo->result_buffer = result_buffer;
	taskInfo->result_size = result_size;
	taskInfo->attributes = attributes;
//	taskInfo->port = __getNextPortNum();
//	taskInfo->endpoint = mcapi_endpoint_create(taskInfo->port, &mcapi_status);
	taskInfo->context = (mtapi_task_context_t *) malloc (sizeof(mtapi_task_context_t));
	taskInfo->FromRemote = IsFromRemote;
	taskInfo->context->status = MTAPI_TASK_SCHEDULED;
	mutex_init(&taskInfo->mutex);

	if (__current_task == NULL) {
		/* this is the first task for program */
		taskInfo->num_children = 0;
		__current_task = taskInfo;
		__current_task->parent = MTAPI_NULL;
		__current_task->child = MTAPI_NULL;
	} else {
		/* this is not the first task for program */
		__current_task->child = taskInfo;
		taskInfo->parent = __current_task;
		taskInfo->child = MTAPI_NULL;
		taskInfo->num_children = 0;
		__current_task->num_children++;
	}
	mutex_lock(&queue->mutex);
	queue_enqueue(queue->seq_task_queue, (void *) taskInfo);
	if (queue->avail == MTAPI_TRUE) {
		void * tmpPtr = queue_dequeue(queue->seq_task_queue);
		if (tmpPtr) {
			queue_enqueue(__task_queue, tmpPtr);
			queue->avail = MTAPI_FALSE;
		}
	}
	mutex_unlock(&queue->mutex);


	return taskInfo;
}
mtapiRT_TaskInfo_t * mtapiRT_startRemoteTask(
		MTAPI_IN mtapi_task_id_t task_id,
		mtapiRT_ActionInfo_t * action,
		MTAPI_IN void * arguments,
		MTAPI_IN mtapi_size_t arguments_size,
		MTAPI_OUT void * result_buffer,
		MTAPI_IN mtapi_size_t result_size,
		MTAPI_IN mtapi_task_attributes_t * attributes,
		MTAPI_OUT mtapi_status_t *status
		)
{
	mcapi_endpoint_t remoteEndpt;
	mcapi_status_t mcapi_status;
	mtapiRT_TaskInfo_t *taskInfo;
	char buffer[MCAPI_MAX_MSG_SIZE];
	unsigned bufferSize;
	unsigned send_size;
	size_t size;

	if (action->status != MTAPIRT_ACTION_CREATED) {
		*status = MTAPI_ERR_ACTION_INVALID;
		return MTAPI_NULL;
	}
	taskInfo = (mtapiRT_TaskInfo_t *) malloc (sizeof(mtapiRT_TaskInfo_t));
	taskInfo->init_node = __mtapi_init_node_id;
	taskInfo->queueID = -1;
	taskInfo->queue = MTAPI_NULL;
	taskInfo->task_id = task_id;
	taskInfo->internal_task_id = __mtapi_task_id++;
	taskInfo->action = action;
	taskInfo->arguments = arguments;
	taskInfo->argument_size = arguments_size;
	taskInfo->result_buffer = result_buffer;
	taskInfo->result_size = result_size;
	taskInfo->attributes = attributes;
//	taskInfo->port = __getNextPortNum();
//	taskInfo->endpoint = mcapi_endpoint_create(taskInfo->port, &mcapi_status);
	taskInfo->context = (mtapi_task_context_t *) malloc (sizeof(mtapi_task_context_t));
	taskInfo->context->status = MTAPI_TASK_SCHEDULED;
	mutex_init(&taskInfo->mutex);
	/* get remote endpoint */
	remoteEndpt = mcapi_endpoint_get(
		NODE_INFOS[action->location.init_node].domain,
		NODE_INFOS[action->location.init_node].node + 1,
		NODE_INFOS[action->location.init_node].lst_recv_port,
		MCAPI_TIMEOUT_INFINITE,
		&mcapi_status
			);
	/* initialize Remote Task Info */
	mtapiRT_RemoteTaskInfo_t * remoteTaskInfo;
	remoteTaskInfo = (mtapiRT_RemoteTaskInfo_t *) malloc (sizeof(mtapiRT_RemoteTaskInfo_t));
	remoteTaskInfo->task_id = task_id;
	remoteTaskInfo->node_id = taskInfo->init_node;
	remoteTaskInfo->job_id = action->jobID;
	remoteTaskInfo->arguments_size = arguments_size;
	remoteTaskInfo->result_buffer = MTAPI_NULL;
	remoteTaskInfo->result_size = result_size;

	/* pack remoteTaskInfo into a message */
	mtapiRT_Message_t * msg;
	msg = (mtapiRT_Message_t *) malloc (sizeof(mtapiRT_Message_t));
	msg->type = MTAPIRT_MSG_START_TASK;
	msg->sender_domain = __mtapi_domain;
	msg->sender_node = __mtapi_node;
	msg->port = 0;
	msg->buffer = (void *) remoteTaskInfo;
	msg->buffer_size = sizeof(mtapiRT_RemoteTaskInfo_t);
	/* pack msg and argmuments into a buffer to send */
	bufferSize = __marshallMessage(msg, buffer);
	memcpy(&buffer[bufferSize], arguments, arguments_size);
	send_size = bufferSize + arguments_size;

	/* send buffer to remote node */
        list_insert(__mtapi_remote_task_list, (void *) taskInfo);	
	mcapi_msg_send(__send_endpoint, remoteEndpt, &buffer, send_size, MCAPI_MAX_PRIORITY, &mcapi_status);
	if(mcapi_status != MCAPI_SUCCESS) {
		printf("sending error\n");
	}

	/* wait on acknowledgement */
	mcapi_msg_recv(__send_endpoint, &buffer, MCAPI_MAX_MSG_SIZE, &size, &mcapi_status);
	if (mcapi_status != MCAPI_SUCCESS) {
		printf("receiving error\n");
	}
	

	__unmarshallMessage(buffer, size, msg);
	memcpy(&taskInfo->external_task_id, msg->buffer, sizeof(unsigned));
//	taskInfo->remote_domain = msg->sender_domain;
//	taskInfo->remote_node = msg->sender_node;
//	TODO: remove __remote_task_queue
//	
/*
	queue_lock(__remote_task_queue);
	queue_enqueue(__remote_task_queue, (void *) taskInfo);
	queue_unlock(__remote_task_queue);
	*/
	mutex_lock(&taskInfo->action->mutex);
	taskInfo->action->running++;
	mutex_unlock(&taskInfo->action->mutex);
//        list_insert(__mtapi_remote_task_list, (void *) taskInfo);	
	return taskInfo;
}

mtapiRT_TaskInfo_t * mtapiRT_startRemoteTaskQueue(
		mtapiRT_QueueInfo_t *queue,
		MTAPI_IN mtapi_task_id_t task_id,
		mtapiRT_ActionInfo_t * action,
		MTAPI_IN void * arguments,
		MTAPI_IN mtapi_size_t arguments_size,
		MTAPI_OUT void * result_buffer,
		MTAPI_IN mtapi_size_t result_size,
		MTAPI_IN mtapi_task_attributes_t * attributes,
		MTAPI_OUT mtapi_status_t *status
		)
{
	mcapi_endpoint_t remoteEndpt;
	mcapi_status_t mcapi_status;
	mtapiRT_TaskInfo_t *taskInfo;
	char buffer[MCAPI_MAX_MSG_SIZE];
	unsigned bufferSize;
	unsigned send_size;
	size_t size;
	if (action->status != MTAPIRT_ACTION_CREATED) {
		*status = MTAPI_ERR_ACTION_INVALID;
		return MTAPI_NULL;
	}
	taskInfo = (mtapiRT_TaskInfo_t *) malloc (sizeof(mtapiRT_TaskInfo_t));
	taskInfo->queue = queue;
	taskInfo->queueID = queue->internal_queue_id;
	taskInfo->task_id = task_id;
	taskInfo->internal_task_id = __mtapi_task_id++;
	taskInfo->action = action;
	taskInfo->arguments = arguments;
	taskInfo->argument_size = arguments_size;
	taskInfo->result_buffer = result_buffer;
	taskInfo->result_size = result_size;
	taskInfo->attributes = attributes;
//	taskInfo->port = __getNextPortNum();
//	taskInfo->endpoint = mcapi_endpoint_create(taskInfo->port, &mcapi_status);
	taskInfo->context = (mtapi_task_context_t *) malloc (sizeof(mtapi_task_context_t));
	taskInfo->context->status = MTAPI_TASK_SCHEDULED;
	mutex_init(&taskInfo->mutex);
	/* get remote endpoint */
	remoteEndpt = mcapi_endpoint_get(
		NODE_INFOS[action->location.init_node].domain,
		NODE_INFOS[action->location.init_node].node + 1,
		NODE_INFOS[action->location.init_node].lst_recv_port,
		MCAPI_TIMEOUT_INFINITE,
		&mcapi_status
			);
	/* initialize Remote Task Info */
	mtapiRT_RemoteTaskInfo_t * remoteTaskInfo;
	remoteTaskInfo = (mtapiRT_RemoteTaskInfo_t *) malloc (sizeof(mtapiRT_RemoteTaskInfo_t));
	remoteTaskInfo->task_id = task_id;
	remoteTaskInfo->job_id = action->jobID;
	remoteTaskInfo->arguments_size = arguments_size;
	remoteTaskInfo->result_buffer = MTAPI_NULL;
	remoteTaskInfo->result_size = result_size;

	/* pack remoteTaskInfo into a message */
	mtapiRT_Message_t * msg;
	msg = (mtapiRT_Message_t *) malloc (sizeof(mtapiRT_Message_t));
	msg->type = MTAPIRT_MSG_START_TASK;
	msg->sender_domain = __mtapi_domain;
	msg->sender_node = __mtapi_node;
	msg->port = 0;
	msg->buffer = (void *) remoteTaskInfo;
	msg->buffer_size = sizeof(mtapiRT_RemoteTaskInfo_t);
	/* pack msg and argmuments into a buffer to send */
	bufferSize = __marshallMessage(msg, buffer);
	memcpy(&buffer[bufferSize], arguments, arguments_size);
	send_size = bufferSize + arguments_size;

	while (1) {
		mutex_lock(&queue->mutex);
		if (queue->avail == MTAPI_TRUE) {
        		list_insert(__mtapi_remote_task_list, (void *) taskInfo);	
			mcapi_msg_send(__send_endpoint, remoteEndpt, &buffer, send_size, MCAPI_MAX_PRIORITY, &mcapi_status);
			queue->avail = MTAPI_FALSE;
			mutex_unlock(&queue->mutex);
			if(mcapi_status != MCAPI_SUCCESS) {
			printf("sending error\n");
			}		

			/* wait on acknowledgement */
			mcapi_msg_recv(__send_endpoint, &buffer, MCAPI_MAX_MSG_SIZE, &size, &mcapi_status);
			if (mcapi_status != MCAPI_SUCCESS) {
			printf("receiving error\n");
			}
	

			__unmarshallMessage(buffer, size, msg);
			memcpy(&taskInfo->external_task_id, msg->buffer, sizeof(unsigned));
			mtapiRT_waitForRemoteTask(taskInfo, MCAPI_TIMEOUT_INFINITE, status);
			mutex_lock(&queue->mutex);
			queue->avail = MTAPI_TRUE;
			mutex_unlock(&queue->mutex);
			break;
		} else {
			mutex_unlock(&queue->mutex);
			mtapiRT_TaskInfo_t * next;
			queue_lock(__task_queue);
			next = (mtapiRT_TaskInfo_t *) queue_dequeue(__task_queue);
			queue_unlock(__task_queue);
			if (next != MTAPI_NULL)
				mtapiRT_switchTask(next);
		}
//	taskInfo->remote_domain = msg->sender_domain;
//	taskInfo->remote_node = msg->sender_node;
//	TODO: remove __remote_task_queue
/*
	queue_lock(__remote_task_queue);
	queue_enqueue(__remote_task_queue, (void *) taskInfo);
	queue_unlock(__remote_task_queue);
	*/
	}
	
	return taskInfo;
}
/*
 * This is a very simple version of task wait. Cannot be used for
 * recursion function calls.
 */

void mtapiRT_deleteTask(mtapiRT_TaskInfo_t * task,
			MTAPI_OUT mtapi_status_t * status
			)
{
//	mcapi_status_t mcapi_status;
	/*
	mcapi_endpoint_delete(task->endpoint, &mcapi_status);
	if (mcapi_status == MCAPI_SUCCESS) {
		__freePort((int)task->port);
	}
 	*/
	mutex_lock(&task->mutex);
	free(task->context);
	mutex_unlock(&task->mutex);
	free(task);	
	*status = MTAPI_SUCCESS;
}

mtapiRT_TaskInfo_t * mtapiRT_waitForLocalTask(mtapiRT_TaskInfo_t * task,
			      MTAPI_IN mtapi_timeout_t timeout,
			      MTAPI_OUT mtapi_status_t *status)
{
	mtapiRT_TaskInfo_t * tmp;
	mtapiRT_TaskInfo_t * next;
	int tag = 0;
	tmp = (mtapiRT_TaskInfo_t *) malloc (sizeof(mtapiRT_TaskInfo_t));
	while(1) {
		/* if task has children */
		/*
		if (task->num_children != 0) {
			next = (mtapiRT_TaskInfo_t *) queue_dequeue(__task_queue);
			mtapiRT_switchTask(next);
		}
		*/
		switch (task->context->status) {
			case MTAPI_TASK_COMPLETED : 
				tag = 1;
				break;
			case MTAPI_TASK_CANCELLED:
				tag = 2;
				break;
		}
		if (tag == 1) {
			*status = MTAPI_SUCCESS;
			tmp->result_buffer = task->result_buffer;
			tmp->result_size = task->result_size;
			/*
			if (*(int *) task->arguments > 19)
				printf("arg = %d  result = %d\n", *(int *) task->arguments, *(int *) task->result_buffer);
				*/
			if (!task->FromRemote)
				mtapiRT_deleteTask(task, status);
			return tmp;
		}
		if (tag == 2) {
			switch (task->action->status) {
				case MTAPIRT_ACTION_DELETED:
					*status = MTAPI_ERR_ACTION_DELETED;
					return MTAPI_NULL;
				case MTAPIRT_ACTION_NULL:
				case MTAPIRT_ACTION_INITIALIZED:
				case MTAPIRT_ACTION_CREATED:
				case MTAPIRT_ACTION_DISABLED:
				case MTAPIRT_ACTION_ENABLE:
					break;
			}

		}
		if (__current_task->num_children != 0) {
			queue_lock(__task_queue);
			next = (mtapiRT_TaskInfo_t *) queue_dequeue(__task_queue);
			queue_unlock(__task_queue);
			if (next != MTAPI_NULL)
				mtapiRT_switchTask(next);
		}
	       /*	else {
			task->action->location.fptr(
				task->arguments,
				task->argument_size,
				task->result_buffer,
				task->result_size,
				task->action->local_data,
				task->action->local_data_size,
				(mtapi_task_context_t * const) task->context);
			task->context->status = MTAPI_TASK_COMPLETED; 

			}
		*/
	}
}
/* Sending message to remote processor to see if task is finished.  *
 * If not yet switch to a local task then back and see		    */
void mtapiRT_waitForRemoteTask(mtapiRT_TaskInfo_t * task,
			       MTAPI_IN mtapi_timeout_t timeout,
			       MTAPI_OUT mtapi_status_t * status)
{
//	mcapi_endpoint_t remoteEP;
//	mtapiRT_TaskInfo_t * tmp;
	mtapiRT_TaskInfo_t * next;
//	int remote_node_id;
//	char buffer[MCAPI_MAX_MSG_SIZE];
//	mtapiRT_Message_t message;
//	mtapiRT_Message_t message2;
//	mcapi_status_t mcapi_status;
//	unsigned buffer_size;
//	size_t size;
//	int ack;
////////////////////////////////////////////////////////////////////////////////////////
//	unit_t *taskPtr;

	while (1) {
		if (task->context->status == MTAPI_TASK_COMPLETED) {


			/* delete task */
			return;
		}
		queue_lock(__task_queue);
		next = (mtapiRT_TaskInfo_t *) queue_dequeue(__task_queue);
		queue_unlock(__task_queue);
		if (next != MTAPI_NULL)
			mtapiRT_switchTask(next);
	}
}
///////////////////////////////////////////////////////////////////////////////////
	/* get the endpoint for remote node's listener thread */
/*        remote_node_id = task->action->location.init_node;
	remoteEP = mcapi_endpoint_get(
			NODE_INFOS[remote_node_id].domain,
			NODE_INFOS[remote_node_id].node + 1,
			NODE_INFOS[remote_node_id].lst_recv_port, 
			MCAPI_TIMEOUT_INFINITE, 
			&mcapi_status);
	ack = 0;
	while (ack == 0) {
		message.type = MTAPIRT_MSG_WAIT_TASK;
		message.sender_domain = __mtapi_domain;
		message.sender_node = __mtapi_node;
//		message.port = task->port;
		message.port = 0;
		message.buffer = (char *) &task->external_task_id;
		message.buffer_size = sizeof(unsigned);

		buffer_size = __marshallMessage (&message, buffer);

		mcapi_msg_send(
			__send_endpoint,
			remoteEP,
			&buffer,
			buffer_size,
			MCAPI_MAX_PRIORITY,
			&mcapi_status
			      );

		mcapi_msg_recv(
//			task->endpoint,
			__send_endpoint,
			&buffer,
			MCAPI_MAX_MSG_SIZE,
			&size,
			&mcapi_status
			      );
		__unmarshallMessage(buffer, size, &message2);
		switch (message2.type) {
			case MTAPIRT_MSG_ACK :
				memcpy(task->result_buffer, message2.buffer, task->result_size);
				task->context->status = MTAPI_TASK_COMPLETED;
				mutex_lock(&task->action->mutex);
				task->action->running--;
				mutex_unlock(&task->action->mutex);
//				printf("task->result_buffer = %d\n", *(int *)task->result_buffer);
				ack = 1;
				*status = MTAPI_SUCCESS;
				return;
				break;
			default:
				break;
		}
		queue_lock(__task_queue);
		next = (mtapiRT_TaskInfo_t *) queue_dequeue(__task_queue);
		queue_unlock(__task_queue);
		if (next != MTAPI_NULL)
			mtapiRT_switchTask(next);

	}
//	mtapiRT_deleteTask(task, status);
}

*/
mtapiRT_JobInfo_t * mtapiRT_getJob(
		MTAPI_IN mtapi_job_id_t job_id,
	        MTAPI_OUT mtapi_status_t *status)
{
	*status = MTAPI_SUCCESS;
	return &__mtapi_jobs[job_id];
}

mtapiRT_ActionInfo_t * mtapiRT_getLocalAction(mtapiRT_JobInfo_t * job, mtapi_status_t *status) 
{	
	if (job->actions == MTAPI_NULL || job->actions->type != MTAPIRT_ACTION_LOCAL) {
		*status = MTAPI_ERR_ACTION_INVALID;
		return MTAPI_NULL;
	}	
	*status = MTAPI_SUCCESS;
	return job->actions;
}

mtapiRT_TaskInfo_t * mtapiRT_getTask(unsigned tid, mtapi_status_t * status) 
{
	int i;
	int queue_size;
	int max_queue_size;
	mtapiRT_TaskInfo_t * task;
	queue_size = queue_getsize(__completed_task_queue);
	max_queue_size = queue_maxsize();

	for (i = 0; i < queue_size; i++) {
		task = (mtapiRT_TaskInfo_t *) __completed_task_queue->elements[(__task_queue->head + i) % max_queue_size];
		if (task != NULL && task->internal_task_id == tid) {
			*status = MTAPI_SUCCESS;
			return task;
		}
	}
	return MTAPI_NULL;
}

void mtapiRT_switchTask(mtapiRT_TaskInfo_t *task) 
{
	mtapiRT_TaskInfo_t *orig_task;
	mtapi_status_t mtapi_status;
	if (task->action->status != MTAPIRT_ACTION_CREATED) {
		task->context->status = MTAPI_TASK_CANCELLED;
		return;
	}
	orig_task = __current_task;
	__current_task = task;
	task->action->location.fptr(
			task->arguments,
			task->argument_size,
			task->result_buffer,
			task->result_size,
			task->action->local_data,
			task->action->local_data_size,
			(mtapi_task_context_t * const) task->context);
	task->context->status = MTAPI_TASK_COMPLETED;
	if (task->queue != MTAPI_NULL) {
		mutex_lock (&task->queue->mutex);
		task->queue->avail = MTAPI_TRUE;
		mutex_unlock(&task->queue->mutex);
	}
	
	if (task->parent == MTAPI_NULL) {
		printf("task: %p   task->parent: %p \n", task, task->parent);
	}
	/* in case the parent is null */
	if (task->parent)
		task->parent->num_children--;
	__current_task = orig_task;
	if (task->FromRemote == 1) {
		mtapiRT_sendResult(task, task->init_node, &mtapi_status);
//		queue_lock(__completed_task_queue);
//		queue_enqueue(__completed_task_queue, (void *)task);
//		queue_unlock(__completed_task_queue);
	}

}
mtapiRT_QueueInfo_t * mtapiRT_createQueue (
		MTAPI_IN mtapi_queue_id_t queue_id,
		mtapiRT_JobInfo_t * job,
		mtapiRT_ActionInfo_t * action,
		MTAPI_IN mtapi_queue_attributes_t * attributes,
		MTAPI_OUT mtapi_status_t * status
		)
{
	mtapiRT_QueueInfo_t * queueObj;
	queueObj = (mtapiRT_QueueInfo_t *) malloc (sizeof(mtapiRT_QueueInfo_t));
	queueObj->avail = MTAPI_TRUE;
	queueObj->external_queue_id = queue_id;
	mutex_lock(&__mtapi_queue_id_mutex);
	queueObj->internal_queue_id = __mtapi_queue_id++;
	mutex_unlock(&__mtapi_queue_id_mutex);
	queueObj->job = job;
	queueObj->action = action;
	queueObj->seq_task_queue = (queue_t *) malloc (sizeof(queue_t));
	queue_init(queueObj->seq_task_queue);
	mutex_init(&queueObj->mutex);
	*status = MTAPI_SUCCESS;
	queueGroup[0] =  queueObj;
	return queueObj;
}

void mtapiRT_sendResult(mtapiRT_TaskInfo_t * task, unsigned node, mtapi_status_t * status)
{
	mcapi_endpoint_t remoteEndpt;
	mcapi_status_t mcapi_status;
	mtapiRT_Message_t *message;
	mtapiRT_Message_t *message2;
	char buffer[MCAPI_MAX_MSG_SIZE];
	char buffer2[MCAPI_MAX_MSG_SIZE];
	char send_buffer[MCAPI_MAX_MSG_SIZE];
	mtapi_uint_t bufferSize;
	unsigned send_size;
	size_t recv_size;
	int ack;
//	sleep(5);

	
	ack = 1;
	remoteEndpt = mcapi_endpoint_get(
			NODE_INFOS[node].domain,
			NODE_INFOS[node].node + 1,
			NODE_INFOS[node].lst_recv_port,
			MCAPI_TIMEOUT_INFINITE,
			&mcapi_status
			);
	//TODO: copy the internal_task_id to the first place of buffer. 
	// internal_task_id here is the external_id in remote side
	// once receive acknowlegement delete the task
	// the remote process find the task from list? twice traverse
	// ??
	memcpy(&buffer[0], (char *)&task->internal_task_id, sizeof(unsigned));
	memcpy(&buffer[sizeof(unsigned)], task->result_buffer, task->result_size);
	bufferSize = sizeof(unsigned) + task->result_size;

	/* initialize message */
	message = (mtapiRT_Message_t *) malloc (sizeof(mtapiRT_Message_t));
	message2 = (mtapiRT_Message_t *) malloc (sizeof(mtapiRT_Message_t));

	message->type = MTAPIRT_MSG_COMPLETE_TASK;
	message->sender_domain = __mtapi_domain;
	message->sender_node = __mtapi_node;
	message->port = 0; /* all the port is 0 except for listener*/
	message->buffer = buffer;
	message->buffer_size = bufferSize;


	send_size = __marshallMessage(message, send_buffer);
	while (ack) {	
		mcapi_msg_send(__send_endpoint, remoteEndpt, &send_buffer, send_size, MCAPI_MAX_PRIORITY, &mcapi_status);
		mcapi_msg_recv(__send_endpoint, &buffer2, MCAPI_MAX_MSG_SIZE, &recv_size, &mcapi_status);
		__unmarshallMessage(buffer2, recv_size, message2);
		
		switch (message2->type) {
			case MTAPIRT_MSG_ACK:
				/* delete task */
				ack = 0;
				break;
			case MTAPIRT_MSG_SYNC:
			case MTAPIRT_MSG_NACK:
			case MTAPIRT_MSG_GET_ACTION:
			case MTAPIRT_MSG_START_TASK:
			case MTAPIRT_MSG_CANCEL_TASK:
			case MTAPIRT_MSG_COMPLETE_TASK:
			case MTAPIRT_MSG_WAIT_TASK:
			case MTAPIRT_MSG_UPDATE_ACTION:
			case MTAPIRT_MSG_UPDATE_ACTION_2:
			case MTAPIRT_MSG_CREATE_ACTION:
			case MTAPIRT_MSG_DELETE_ACTION:
			case MTAPIRT_MSG_DISABLE_ACTION:
			case MTAPIRT_MSG_ENABLE_ACTION:
				break;
		}
	}
	/* TODO: wait for acknowledgement */
	/* is this necessary ?*/
}
/********************************************************************
  	utility functions
  ******************************************************************/

/*
 * return the next available port
 */
int __getNextPortNum()
{
	int i;
	mutex_lock(&__portMutex);
	for (i = 3; i < MCAPI_MAX_ENDPOINTS; i++) {
		if (__portNum[i] == 0) {
			__portNum[i] = 1;
			mutex_unlock(&__portMutex);
			return i;
		}
	}
	return 0;
}

/*
 * free previous port (when task delete)
 */

void __freePort(int port_id) 
{
	mutex_lock(&__portMutex);
	__portNum[port_id] = 0;
	mutex_unlock(&__portMutex);
}	

/*
 *  marshall message to buffer. send buffer using mcapi api 
 *  
 */
unsigned __marshallMessage(mtapiRT_Message_t *message, char * buffer) 
{
	unsigned i, type_size, sender_domain_size, sender_node_size, port_size;
	type_size = sizeof(message->type);
	sender_domain_size = sizeof(message->sender_domain);
	sender_node_size = sizeof(message->sender_node);
	port_size = sizeof(message->port);

	memcpy(&buffer[0], &message->type, type_size);
	memcpy(&buffer[type_size], &message->sender_domain, sender_domain_size);
	memcpy(&buffer[type_size + sender_domain_size], &message->sender_node, sender_node_size);
	memcpy(&buffer[type_size + sender_domain_size + sender_node_size], &message->port, port_size);
	/*  copy message buffer to sending buffer  */
	for (i = 0; i < message->buffer_size; i++) {
		buffer[i + type_size + sender_domain_size + sender_node_size + port_size] = message->buffer[i];
	}
	/*  return size of marshalled buffer */
	return (type_size + sender_domain_size + sender_node_size + port_size + message->buffer_size);
}

/*
 *  unpackage receiving buffer to message type struct
 */
mtapi_boolean_t __unmarshallMessage(char * buffer, unsigned buffer_size, mtapiRT_Message_t * message)
{
	unsigned type_size, sender_domain_size, sender_node_size, port_size;
	type_size = sizeof(message->type);
	sender_domain_size = sizeof(message->sender_domain);
	sender_node_size = sizeof(message->sender_node);
	port_size = sizeof(message->port);
	message->buffer_size = buffer_size - (type_size + sender_domain_size + sender_node_size +port_size);

	memcpy(&message->type, &buffer[0], type_size);
	memcpy(&message->sender_domain, &buffer[type_size], sender_domain_size);
	memcpy(&message->sender_node, &buffer[type_size + sender_domain_size], sender_node_size);
	memcpy(&message->port, &buffer[type_size + sender_domain_size + sender_node_size], port_size);
	/*  malloc a new space for message->buffer to store contants
	    from receiving buffer */
	char *new_buffer = (char *) malloc (message->buffer_size);
	if (new_buffer == MTAPI_NULL) {
		fprintf(stderr, "__unmarshallMessage: malloc failure\n");
		return MTAPI_FALSE;
	}
	memcpy(new_buffer, &buffer[type_size + sender_domain_size + sender_node_size + port_size], message->buffer_size);
	message->buffer = new_buffer;

	return MTAPI_TRUE;
}

void __lst_startTask(mtapiRT_Message_t * message, mcapi_endpoint_t sendEP, mcapi_endpoint_t recvEP)
{	
	int isFromRemote;
	mtapi_status_t status;
	mcapi_status_t mcapi_status;
	mtapiRT_ActionInfo_t * action;
	mtapiRT_TaskInfo_t * taskInfo;
	mtapiRT_RemoteTaskInfo_t * remoteTaskInfo;
	mtapiRT_Message_t answer;
	unsigned answer_buffer_size;
	char buffer[MCAPI_MAX_MSG_SIZE];
	remoteTaskInfo = (mtapiRT_RemoteTaskInfo_t *) message->buffer;
	void * arguments = malloc(remoteTaskInfo->arguments_size);
	remoteTaskInfo->result_buffer = malloc(remoteTaskInfo->result_size);
	memcpy(arguments, &message->buffer[sizeof(mtapiRT_RemoteTaskInfo_t)], remoteTaskInfo->arguments_size);

	action = mtapiRT_getLocalAction(&__mtapi_jobs[remoteTaskInfo->job_id], &status);
	isFromRemote = 1;
	
	
	taskInfo = mtapiRT_startLocalTask(
			isFromRemote,
			remoteTaskInfo->node_id,	
			remoteTaskInfo->task_id,
			action,
			arguments,
			remoteTaskInfo->arguments_size,
			remoteTaskInfo->result_buffer,
			remoteTaskInfo->result_size,
			MTAPI_NULL,
			&status);

	answer.type = MTAPIRT_MSG_ACK;
	answer.sender_domain = __mtapi_domain;
	answer.sender_node = __mtapi_node;
	answer.port = NODE_INFOS[__mtapi_init_node_id].lst_recv_port;
	answer.buffer = (char *)&taskInfo->internal_task_id;
	answer.buffer_size = sizeof(unsigned);

	answer_buffer_size = __marshallMessage(&answer, buffer);
	mcapi_msg_send(
			sendEP,
			recvEP,
			&buffer,
			answer_buffer_size,
			MCAPI_MAX_PRIORITY,
			&mcapi_status
			);
}

void __lst_waitForTask(mtapiRT_Message_t * message, mcapi_endpoint_t sendEP, mcapi_endpoint_t recvEP)
{
	unsigned task_id;
	mtapiRT_Message_t answer;
	mtapiRT_TaskInfo_t *task_info;
//	mtapiRT_TaskInfo_t *tmp;
	mtapi_status_t mtapi_status;
	mcapi_status_t mcapi_status;
	unsigned bufferSize;
	char buffer[MCAPI_MAX_MSG_SIZE];
	memcpy(&task_id, message->buffer, message->buffer_size);

	answer.type = MTAPIRT_MSG_NACK;
	answer.sender_domain= __mtapi_domain;
	answer.sender_node = __mtapi_node;
	answer.port = NODE_INFOS[__mtapi_init_node_id].lst_recv_port;
	answer.buffer = NULL;
	answer.buffer_size = 0;

	/* find the taskInfo from the __completed queue */
	/* TODO there is a bug in this section		*
	 * the complete task queue is not initialized 	*
	 * there may be an unitialize part which has 	*
	 * the same value of task_id			*/
	task_info = mtapiRT_getTask(task_id, &mtapi_status);

	if (task_info != MTAPI_NULL) {

//		tmp = mtapiRT_waitForLocalTask(task_info, MTAPI_TIMEOUT_INFINITE, &mtapi_status);
		answer.type = MTAPIRT_MSG_ACK;
//		printf("result buffer = %p   arguments = %d  task_result = %d\n",task_info, *(int *)task_info->arguments,  *(int *) task_info->result_buffer);
		answer.buffer = (char *)task_info->result_buffer;
		answer.buffer_size = task_info->result_size;
	}
	bufferSize = __marshallMessage(&answer, buffer);
	mcapi_msg_send(sendEP,
		       recvEP,
		       &buffer,
		       bufferSize,
		       MCAPI_MAX_PRIORITY,
		       &mcapi_status);
}


void __lst_updateAction(mtapiRT_Message_t * message, mcapi_endpoint_t sendEP, mcapi_endpoint_t recvEP)
{
	int i;
	mcapi_status_t mcapi_status;
	mtapiRT_ActionUpdate_t * remoteUpdate;
	mtapiRT_Message_t * msg;
	unsigned send_size;
	char buffer[MCAPI_MAX_MSG_SIZE];
	mtapiRT_ActionInfo_t * tmp;
	mcapi_endpoint_t remoteEndpt;
	remoteUpdate = (mtapiRT_ActionUpdate_t* )message->buffer;
	remoteEndpt = mcapi_endpoint_get(
			NODE_INFOS[remoteUpdate->init_node].domain,
			NODE_INFOS[remoteUpdate->init_node].node + 1,
			NODE_INFOS[remoteUpdate->init_node].lst_recv_port,
			MCAPI_TIMEOUT_INFINITE,
		    	&mcapi_status 
			);
	printf("in updateAction receving\n");
	for (i = 0; i < remoteUpdate->num_created_action; i++) {
		tmp = __mtapi_jobs[remoteUpdate->job[i]].actions;
		while (tmp != MTAPI_NULL) {
			if (tmp->type == MTAPIRT_ACTION_LOCAL) {
				tmp = tmp->next;
			} else if (tmp->location.init_node == remoteUpdate->init_node) {
				mutex_lock(&tmp->mutex);
				tmp->status = MTAPIRT_ACTION_CREATED;
				mutex_unlock(&tmp->mutex);
				break;
			} else {
				tmp = tmp->next;
			}
		}
	}
	printf("in updateAction updating\n");

	/* send back the local action information on this node */
	mtapiRT_ActionUpdate_t * update;
	int cnt = 0;
	int j = 0;
	update = (mtapiRT_ActionUpdate_t *) malloc (sizeof(mtapiRT_ActionUpdate_t));

	for (i = 0; i < NODE_INFOS[__mtapi_init_node_id].num_actions; i++) {
		if (__mtapi_actions[i].status == MTAPIRT_ACTION_CREATED) {
			update->job[j++] = __mtapi_actions[i].jobID;
			cnt++;
		}
	}
	update->num_created_action = cnt;
	update->init_node = __mtapi_init_node_id;


        msg = (mtapiRT_Message_t *) malloc (sizeof(mtapiRT_Message_t));	
	msg->type = MTAPIRT_MSG_UPDATE_ACTION_2;
	msg->sender_domain = __mtapi_domain;
	msg->sender_node = __mtapi_node;
	msg->port = 0;
	msg->buffer = (void *) update;
	msg->buffer_size = sizeof(mtapiRT_ActionUpdate_t);
	send_size = __marshallMessage(msg, buffer);
	mcapi_msg_send(sendEP, remoteEndpt, &buffer, send_size, MCAPI_MAX_PRIORITY, &mcapi_status);
	printf("in updateAction finishing\n");

}

void __lst_updateAction2(mtapiRT_Message_t * message, mcapi_endpoint_t sendEP, mcapi_endpoint_t recvEP)
{
//	puts("_++++++++++++++++++++++++++++");
	
	int i;
//	mcapi_status_t mcapi_status;
	mtapiRT_ActionUpdate_t * remoteUpdate;
//	mtapiRT_Message_t answer;
//	unsigned answer_buffer_size;
//	char buffer[MCAPI_MAX_MSG_SIZE];
	mtapiRT_ActionInfo_t * tmp;
	remoteUpdate = (mtapiRT_ActionUpdate_t* )message->buffer;
	printf("in updateAction2 receiving from node  %d   %d\n", remoteUpdate->init_node, remoteUpdate->num_created_action );
	for (i = 0; i < remoteUpdate->num_created_action; i++) {
		tmp = __mtapi_jobs[remoteUpdate->job[i]].actions;
		while (tmp != MTAPI_NULL) {
			if (tmp->type == MTAPIRT_ACTION_LOCAL) {
				tmp = tmp->next;
			} else if (tmp->location.init_node == remoteUpdate->init_node) {
				mutex_lock(&tmp->mutex);
				printf("created\n");
				tmp->status = MTAPIRT_ACTION_CREATED;
				mutex_unlock(&tmp->mutex);
				break;
			} else {
				tmp = tmp->next;
			}
		}
	}

}
void __lst_updateActionDelete(mtapiRT_Message_t * message, mcapi_endpoint_t sendEP, mcapi_endpoint_t recvEP)
{
	int i;
	mtapiRT_ActionUpdate_t * remoteUpdate;
	mtapiRT_ActionInfo_t * tmp;
	printf("in updateAction receving\n");
	remoteUpdate = (mtapiRT_ActionUpdate_t* )message->buffer;
	for (i = 0; i < remoteUpdate->num_created_action; i++) {
		tmp = __mtapi_jobs[remoteUpdate->job[i]].actions;
		while (tmp != MTAPI_NULL) {
			if (tmp->type == MTAPIRT_ACTION_LOCAL) {
				tmp = tmp->next;
			} else if (tmp->location.init_node == remoteUpdate->init_node) {
				mutex_lock(&tmp->mutex);
				tmp->status = MTAPIRT_ACTION_DELETED;
				mutex_unlock(&tmp->mutex);
				break;
			} else {
				tmp = tmp->next;
			}
		}
	}
}
void __lst_taskCompleted(mtapiRT_Message_t * message, mcapi_endpoint_t sendEP, mcapi_endpoint_t recvEP)
{
	/* find the task from __mtapi_remote_task_list */
	/* remove node from __mtapi_remote_task_list */
	/* copy from message->buffer to result->buffer*/
	/* switch task->context->status */
	unsigned external_id;
	char buffer[MCAPI_MAX_MSG_SIZE];
	unsigned send_size;
	mtapi_status_t mtapi_status;
	mtapiRT_Message_t * answer;
	memcpy(&external_id, message->buffer, sizeof(unsigned));
	unit_t * taskPtr;
	mtapiRT_TaskInfo_t * task;
	taskPtr = __mtapi_remote_task_list->head;
	answer = (mtapiRT_Message_t *) malloc (sizeof(mtapiRT_Message_t));
	answer->type = MTAPIRT_MSG_ACK;
	answer->sender_domain = __mtapi_domain;
	answer->sender_node = __mtapi_node;
	answer->port = NODE_INFOS[__mtapi_init_node_id].lst_recv_port;
	answer->buffer = MTAPI_NULL;
	answer->buffer_size = 0;
	send_size = __marshallMessage(answer, buffer);
	while (taskPtr) {
		task = (mtapiRT_TaskInfo_t *) taskPtr->ptr;
		if (task->external_task_id == external_id) {
			memcpy(task->result_buffer, &message->buffer[sizeof(unsigned)], message->buffer_size - sizeof(unsigned));
			task->context->status = MTAPI_TASK_COMPLETED;
			mutex_lock(&task->mutex);
			task->action->running--;
			mutex_unlock(&task->mutex);
			__sync_fetch_and_add(&task->action->cnt, -1);
			list_delete(__mtapi_remote_task_list, taskPtr);
			mcapi_msg_send(sendEP, recvEP, &buffer, send_size, MCAPI_MAX_PRIORITY, &mtapi_status);
			return;
		}
		taskPtr = taskPtr->next;
		if (taskPtr == MTAPI_NULL) {
			taskPtr = __mtapi_remote_task_list->head;
		}
	}
}
void * test1()
{
	return NULL;
}




void mtapi_test()
{
}

#ifdef __cplusplus
  extern }
#endif


















